# 동시성 제어 방식 분석

## Lock 기반 동시성 제어

- 잠금 기반 방식은 트랜잭션이 데이터에 접근할 때 데이터를 잠그고, 다른 트랜잭션이 해당 데이터에 접근하지 못하게 하는 방식입니다.
- 확장 단계(Growing Phase)에서는 락을 획득만 할 수 있고, 수축 단계(Shrinking Phase)에서는 락을 해제만 할 수 있어 직렬성을 보장. 이를 통해 트랜잭션의 일관성을 유지.
- 교착상태(Deadlock), 기아현상(Starvation) 발생 가능성이 있지만, 구현이 단순하고 직관적이라는 장점이 있음.

## 타임스탬프 기반 프로토콜 (Timestamp-Based Protocol)
- 각 트랜잭션에 고유한 타임스탬프를 부여하여 실행 순서를 결정하고 트랜잭션 간의 순서를 보장.
- 교착상태는 발생하지 않지만, 오래된 타임스탬프를 가진 트랜잭션의 잦은 철회가 성능에 영향을 미칠 수 있음.

## 낙관적 동시성 제어 (Optimistic Concurrency Control)

- 트랜잭션이 실행되는 동안 잠금을 사용하지 않고, 최종적으로 커밋을 시도할 때 데이터의 충돌 여부를 검사하여 충돌이 발생하지 않으면 트랜잭션을 완료하는 방식
- 트랜잭션 충돌이 잦지 않은 경우 사용, 아래의 세 단계로 구성된다.
    1. 읽기 단계: 데이터를 읽고 로컬에서 작업
    2. 검증 단계: 다른 트랜잭션과의 충돌 검사
    3. 쓰기 단계: 검증 성공시 결과 반영


- 락 관리 오버헤드가 없어 높은 병렬성을 제공한다.
- 충돌이 빈번한 환경에서는 잦은 재시작으로 성능이 저하 가능성

## 다중버전 동시성 제어 (MVCC)

- 데이터의 여러 버전을 유지하면서 읽기 작업이 쓰기 작업을 차단하지 않도록 한다.
- 트랜잭션은 자신의 타임스탬프에 해당하는 버전의 데이터에 접근한다.

- PostgreSQL, Oracle 등 현대 데이터베이스에서 널리 사용된다.
- 읽기 작업이 많은 시스템에서 특히 효과적이며, 높은 동시성을 제공

## 분산 환경의 동시성 제어

### 분산 락 시스템
- Zookeeper, Redis 등을 활용하여 여러 노드 간 일관되게 락 관리
- 네트워크 파티션과 노드 실패에 대한 고려가 필수적임

## 선택 시 고려사항

1. 시스템 특성
    - 읽기/쓰기 비율
    - 동시 접근 빈도
    - 트랜잭션 크기와 복잡도

2. 성능 요구사항
    - 응답 시간
    - 처리량
    - 확장성

3. 일관성 수준
    - 강한 일관성 vs 최종 일관성
    - 격리 수준 요구사항

- Lock 기반 방식은 일관성을 보장하지만 성능이 떨어지고 교착상태나 기아현상과 같은 문제가 발생 가능
- 타임 스탬프 기반 방식은 교착상태가 발생하지 않지만, 트랜잭션 롤백이 많이 발생할 수 있습니다.
- 낙관적 동시성 제어 방식은 성능이 우수하지만, 충돌이 잦으면 성능 저하가 발생할 수 있습니다.
